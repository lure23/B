/* automatically generated by rust-bindgen 0.71.1 */
#![allow(unused)]

#[doc = " @brief 'VL53L5CX_Platform' is an opaque structure, provided by the customer's app.\n      Gets placed \"as-is\" (as value) into 'VL53L5CX_Configuration', in the vendor code,\n      and a pointer to that \"slot\" is passed to customer-provided functions.\n\n      What I could do:\n          Change the definition of 'VL53L5CX_Configuration' so that the 'platform' field\n          is an extension (empty array) as the *last* entry (now it's the first one).\n          + would allow us to define its contents within Rust\n          - would need patching the C sources (doable)\n\n      Or:\n          Define the *contents* of the 'VL.._Platform' here (in '.h'), so that both Rust\n          and vendor driver can read it (it's no longer opaque to the vendor driver, but\n          that doesn't matter).\n          + no patching of vendor C sources needed (for this)\n          - need to juggle between '.h' and Rust, if fields are changed\n\n      Or:\n          Skip trying to sync .h/Rust, and just consume enough *space* here, that the Rust\n          'Platform' contents fit in it.\n          + neat (though hack); is maintainable because we can automatically check ('sizeof') that the space is enough"]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug)]
pub struct VL53L5CX_Platform {
    pub __: [u8; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VL53L5CX_Platform"][::core::mem::size_of::<VL53L5CX_Platform>() - 24usize];
    ["Alignment of VL53L5CX_Platform"][::core::mem::align_of::<VL53L5CX_Platform>() - 8usize];
    ["Offset of field: VL53L5CX_Platform::__"]
        [::core::mem::offset_of!(VL53L5CX_Platform, __) - 0usize];
};
#[doc = " @brief Structure VL53L5CX_Configuration contains the sensor configuration.\n User MUST not manually change these fields."]
#[repr(C)]
#[derive(Debug)]
pub struct VL53L5CX_Configuration {
    pub platform: VL53L5CX_Platform,
    pub streamcount: u8,
    pub data_read_size: u32,
    pub default_configuration: *mut u8,
    pub default_xtalk: *mut u8,
    pub offset_data: [u8; 488usize],
    pub xtalk_data: [u8; 776usize],
    pub temp_buffer: [u8; 1024usize],
    pub is_auto_stop_enabled: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VL53L5CX_Configuration"]
        [::core::mem::size_of::<VL53L5CX_Configuration>() - 2336usize];
    ["Alignment of VL53L5CX_Configuration"]
        [::core::mem::align_of::<VL53L5CX_Configuration>() - 8usize];
    ["Offset of field: VL53L5CX_Configuration::platform"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, platform) - 0usize];
    ["Offset of field: VL53L5CX_Configuration::streamcount"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, streamcount) - 24usize];
    ["Offset of field: VL53L5CX_Configuration::data_read_size"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, data_read_size) - 28usize];
    ["Offset of field: VL53L5CX_Configuration::default_configuration"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, default_configuration) - 32usize];
    ["Offset of field: VL53L5CX_Configuration::default_xtalk"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, default_xtalk) - 36usize];
    ["Offset of field: VL53L5CX_Configuration::offset_data"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, offset_data) - 40usize];
    ["Offset of field: VL53L5CX_Configuration::xtalk_data"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, xtalk_data) - 528usize];
    ["Offset of field: VL53L5CX_Configuration::temp_buffer"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, temp_buffer) - 1304usize];
    ["Offset of field: VL53L5CX_Configuration::is_auto_stop_enabled"]
        [::core::mem::offset_of!(VL53L5CX_Configuration, is_auto_stop_enabled) - 2328usize];
};
#[doc = " @brief Structure VL53L5CX_ResultsData contains the ranging results of\n VL53L5CX. If user wants more than 1 target per zone, the results can be split\n into 2 sub-groups :\n - Per zone results. These results are common to all targets (ambient_per_spad\n , nb_target_detected and nb_spads_enabled).\n - Per target results : These results are different relative to the detected\n target (signal_per_spad, range_sigma_mm, distance_mm, reflectance,\n target_status)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VL53L5CX_ResultsData {
    pub silicon_temp_degc: i8,
    pub distance_mm: [i16; 64usize],
    pub target_status: [u8; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VL53L5CX_ResultsData"][::core::mem::size_of::<VL53L5CX_ResultsData>() - 194usize];
    ["Alignment of VL53L5CX_ResultsData"][::core::mem::align_of::<VL53L5CX_ResultsData>() - 2usize];
    ["Offset of field: VL53L5CX_ResultsData::silicon_temp_degc"]
        [::core::mem::offset_of!(VL53L5CX_ResultsData, silicon_temp_degc) - 0usize];
    ["Offset of field: VL53L5CX_ResultsData::distance_mm"]
        [::core::mem::offset_of!(VL53L5CX_ResultsData, distance_mm) - 2usize];
    ["Offset of field: VL53L5CX_ResultsData::target_status"]
        [::core::mem::offset_of!(VL53L5CX_ResultsData, target_status) - 130usize];
};
unsafe extern "C" {
    #[doc = " @brief Mandatory function used to initialize the sensor. This function must\n be called after a power on, to load the firmware into the VL53L5CX. It takes\n a few hundred milliseconds.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @return (uint8_t) status : 0 if initialization is OK."]
    pub fn vl53l5cx_init(p_dev: *mut VL53L5CX_Configuration) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function is used to get the current sensor power mode.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint8_t) *p_power_mode : Current power mode. The value of this\n pointer is equal to 0 if the sensor is in low power,\n (VL53L5CX_POWER_MODE_SLEEP), or 1 if sensor is in standard mode\n (VL53L5CX_POWER_MODE_WAKEUP).\n @return (uint8_t) status : 0 if power mode is OK"]
    pub fn vl53l5cx_get_power_mode(p_dev: *mut VL53L5CX_Configuration, p_power_mode: *mut u8)
        -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function is used to set the sensor in Low Power mode, for\n example if the sensor is not used during a long time. The macro\n VL53L5CX_POWER_MODE_SLEEP can be used to enable the low power mode. When user\n want to restart the sensor, he can use macro VL53L5CX_POWER_MODE_WAKEUP.\n Please ensure that the device is not streaming before calling the function.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint8_t) power_mode : Selected power mode (VL53L5CX_POWER_MODE_SLEEP\n or VL53L5CX_POWER_MODE_WAKEUP)\n @return (uint8_t) status : 0 if power mode is OK, or 127 if power mode\n requested by user is not valid."]
    pub fn _vl53l5cx_set_power_mode(p_dev: *mut VL53L5CX_Configuration, power_mode: u8) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function starts a ranging session. When the sensor streams, host\n cannot change settings 'on-the-fly'.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @return (uint8_t) status : 0 if start is OK."]
    pub fn vl53l5cx_start_ranging(p_dev: *mut VL53L5CX_Configuration) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function stops the ranging session. It must be used when the\n sensor streams, after calling vl53l5cx_start_ranging().\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @return (uint8_t) status : 0 if stop is OK"]
    pub fn vl53l5cx_stop_ranging(p_dev: *mut VL53L5CX_Configuration) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function checks if a new data is ready by polling I2C. If a new\n data is ready, a flag will be raised.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint8_t) *p_isReady : Value of this pointer be updated to 0 if data\n is not ready, or 1 if a new data is ready.\n @return (uint8_t) status : 0 if I2C reading is OK"]
    pub fn vl53l5cx_check_data_ready(p_dev: *mut VL53L5CX_Configuration, p_isReady: *mut u8) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function gets the ranging data, using the selected output and the\n resolution.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (VL53L5CX_ResultsData) *p_results : VL53L5 results structure.\n @return (uint8_t) status : 0 data are successfully get."]
    pub fn vl53l5cx_get_ranging_data(
        p_dev: *mut VL53L5CX_Configuration,
        p_results: *mut VL53L5CX_ResultsData,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function sets a new resolution (4x4 or 8x8).\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint8_t) resolution : Use macro VL53L5CX_RESOLUTION_4X4 or\n VL53L5CX_RESOLUTION_8X8 to set the resolution.\n @return (uint8_t) status : 0 if set resolution is OK."]
    pub fn vl53l5cx_set_resolution(p_dev: *mut VL53L5CX_Configuration, resolution: u8) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function sets a new ranging frequency in Hz. Ranging frequency\n corresponds to the measurements frequency. This setting depends of\n the resolution, so please select your resolution before using this function.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint8_t) frequency_hz : Contains the ranging frequency in Hz.\n - For 4x4, min and max allowed values are : [1;60]\n - For 8x8, min and max allowed values are : [1;15]\n @return (uint8_t) status : 0 if ranging frequency is OK, or 127 if the value\n is not correct."]
    pub fn vl53l5cx_set_ranging_frequency_hz(
        p_dev: *mut VL53L5CX_Configuration,
        frequency_hz: u8,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function sets a new integration time in ms. Integration time must\n be computed to be lower than the ranging period, for a selected resolution.\n Please note that this function has no impact on ranging mode continous.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint32_t) time_ms : Contains the integration time in ms. For all\n resolutions and frequency, the minimum value is 2ms, and the maximum is\n 1000ms.\n @return (uint8_t) status : 0 if set integration time is OK."]
    pub fn vl53l5cx_set_integration_time_ms(
        p_dev: *mut VL53L5CX_Configuration,
        integration_time_ms: u32,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function sets a new sharpener value in percent. Sharpener can be\n changed to blur more or less zones depending of the application. Min value is\n 0 (disabled), and max is 99.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint32_t) sharpener_percent : Value between 0 (disabled) and 99%.\n @return (uint8_t) status : 0 if set sharpener is OK."]
    pub fn vl53l5cx_set_sharpener_percent(
        p_dev: *mut VL53L5CX_Configuration,
        sharpener_percent: u8,
    ) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function sets a new target order. Please use macros\n VL53L5CX_TARGET_ORDER_STRONGEST and VL53L5CX_TARGET_ORDER_CLOSEST to define\n the new output order. By default, the sensor is configured with the strongest\n output.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint8_t) target_order : Required target order.\n @return (uint8_t) status : 0 if set target order is OK, or 127 if target\n order is unknown."]
    pub fn vl53l5cx_set_target_order(p_dev: *mut VL53L5CX_Configuration, target_order: u8) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief This function is used to set the ranging mode. Two modes are\n available using ULD : Continuous and autonomous. The default\n mode is Autonomous.\n @param (VL53L5CX_Configuration) *p_dev : VL53L5CX configuration structure.\n @param (uint8_t) ranging_mode : Use macros VL53L5CX_RANGING_MODE_CONTINUOUS,\n VL53L5CX_RANGING_MODE_CONTINUOUS.\n @return (uint8_t) status : 0 if set ranging mode is OK."]
    pub fn vl53l5cx_set_ranging_mode(p_dev: *mut VL53L5CX_Configuration, ranging_mode: u8) -> u8;
}
pub const API_REVISION: &[u8; 15] = b"VL53L5CX_2.0.0\0";
#[doc = " @brief Status of operations.\n\n     Note that official documentation only mentions these cases:\n\n         |||\n         |---|---|\n         |0|No error|\n         |127|invalid value (from the application)|\n         |255|major error (usually timeout in I2C)|\n         |other|\"combination of multiple errors\"|\n\n     This means listing anything else in the API would not really make sense.\n\n     Note: Also the app side code ('RdMulti', 'MsWait' etc.) affects the codes.\n"]
pub const ST_OK: u8 = 0;
pub const ST_ERROR: u8 = 255;
